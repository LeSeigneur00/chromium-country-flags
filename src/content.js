// Source: https://github.com/talkjs/country-flag-emoji-polyfill
const fontName = "Twemoji Country Flags";
const fontUrl = chrome.runtime.getURL("assets/TwemojiCountryFlags.woff2");

/**
 * Register the custom font-face to load the emoji-font for certain unicodes.
 */
const style = document.createElement("style");

// Unicode range generated by: https://wakamaifondue.com/beta/
style.textContent = `
    @font-face {
        font-family: "${fontName}";
        src: url('${fontUrl}') format('woff2');
        unicode-range: U+1F1E6-1F1FF, U+1F3F4, U+E0062-E0063, U+E0065, U+E0067, U+E006C, U+E006E, U+E0073-E0074, U+E0077, U+E007F;
    }
`;
document.head.appendChild(style);

/**
 * Update all children of the given node.
 */
const updateChildNodes = (node) => 
{
    node.querySelectorAll('*').forEach((node) =>
    {
        // Match any emoji within the Unicode range
        const regex = /[\uD83C][\uDDE6-\uDDFF][\uD83C][\uDDE6-\uDDFF]/g;
        const matches = node.innerHTML.match(regex);
        if (matches) 
        {
            // Get the original fonts to append later as fallback
            const originalFont = window.getComputedStyle(node, null).fontFamily;

            // Prevent any duplicated
            if (originalFont.toLowerCase().includes(fontName.toLowerCase())) 
                return;

            // Override the font
            node.style.fontFamily = `${fontName}, ${originalFont}`;
        }
    });
}

// Execute the initial replacement
updateChildNodes(document.body);

// Some elements can be ignored.
const ignoredElements = ['script', 'svg'];

/**
 *  Observe the document for updated elements (e.g. scroll loading).
 */
let observer = new MutationObserver(mutations => 
{ 
    for (let mutation of mutations) 
    {
        for (let node of mutation.addedNodes) 
        {
            if (node == null || node.tagName == null)
                continue;

            const tagName = node.tagName.toLowerCase();
            if (ignoredElements.includes(tagName))
                continue;

            if (node.style == null)
                continue;
            
            updateChildNodes(node);
        }
    }   
});

observer.observe(document, { childList: true, subtree: true });